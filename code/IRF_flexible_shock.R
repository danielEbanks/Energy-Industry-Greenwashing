

### Phi corrected

Phi_corrected <-function (x, nstep = 10,shock=0.1, ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  K <- x$K
  p <- x$p
  A <- as.array(Acoef(x))
  if (nstep >= p) {
    As <- array(0, dim = c(K, K, nstep + 1))
    for (i in (p + 1):(nstep + 1)) {
      As[, , i] <- matrix(0, nrow = K, ncol = K)
    }
  }
  else {
    As <- array(0, dim = c(K, K, p))
  }
  for (i in 1:p) {
    As[, , i] <- (A[[i]])
  }
  Phi <- array(0, dim = c(K, K, nstep + 1))
  Phi[, , 1] <- diag(K)*shock
  Phi[, , 2] <- Phi[, , 1] %*% As[, , 1]
  if (nstep > 1) {
    for (i in 3:(nstep + 1)) {
      tmp1 <- Phi[, , 1] %*% As[, , i - 1]
      tmp2 <- matrix(0, nrow = K, ncol = K)
      idx <- (i - 2):1
      for (j in 1:(i - 2)) {
        tmp2 <- tmp2 + Phi[, , j + 1] %*% As[, , idx[j]]
      }
      Phi[, , i] <- tmp1 + tmp2
    }
  }
  return(Phi)
}




### psi corrected
Psi_corrected <-function (x, nstep = 10,shock=shock, ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  Phi <- Phi_corrected(x, nstep = nstep,shock=shock)
  Psi <- array(0, dim = dim(Phi))
  params <- ncol(x$datamat[, -c(1:x$K)])
  sigma.u <- crossprod(resid(x))/(x$obs - params)
  P <- t(chol(sigma.u))
  dim3 <- dim(Phi)[3]
  for (i in 1:dim3) {
    Psi[, , i] <- Phi[, , i] %*% sigma.u
  }
  return(Psi)
}


.irf<-function (x, impulse, response, y.names, n.ahead, ortho, cumulative,shock=shock) 
{
  if ((class(x) == "varest") || (class(x) == "vec2var")) {
    if (ortho) {
      irf <- Psi_corrected(x, nstep = n.ahead,shock=shock)
    }
    else {
      irf <- Phi_corrected(x, nstep = n.ahead,shock=shock)
    }
  }
  else if ((class(x) == "svarest") || (class(x) == "svecest")) {
    irf <- Phi_corrected(x, nstep = n.ahead,shock=shock)
  }
  dimnames(irf) <- list(y.names, y.names, NULL)
  idx <- length(impulse)
  irs <- list()
  for (i in 1:idx) {
    irs[[i]] <- matrix(t(irf[response, impulse[i], 1:(n.ahead + 
                                                        1)]), nrow = n.ahead + 1)
    colnames(irs[[i]]) <- response
    if (cumulative) {
      if (length(response) > 1) 
        irs[[i]] <- apply(irs[[i]], 2, cumsum)
      if (length(response) == 1) {
        tmp <- matrix(cumsum(irs[[i]]))
        colnames(tmp) <- response
        irs[[i]] <- tmp
      }
    }
  }
  names(irs) <- impulse
  result <- irs
  return(result)
}


## Bootstrap

.boot <-function (x, n.ahead, runs, ortho, cumulative, impulse, response, 
                  ci, seed,shock, y.names) 
{
  if (!(is.null(seed))) 
    set.seed(abs(as.integer(seed)))
  if (class(x) == "varest") {
    VAR <- eval.parent(x)
  }
  else if (class(x) == "svarest") {
    VAR <- eval.parent(x$var)
  }
  else {
    stop("Bootstrap not implemented for this class.\n")
  }
  p <- VAR$p
  K <- VAR$K
  obs   <- VAR$obs
  total <- VAR$totobs
  type  <- VAR$type
  B     <- Bcoef(VAR)
  BOOT <- vector("list", runs)
  ysampled <- matrix(0, nrow = total, ncol = K)
  colnames(ysampled) <- colnames(VAR$y)
  Zdet <- NULL
  if (ncol(VAR$datamat) > (K * (p + 1))) {
    Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
  }
  resorig <- scale(resid(VAR), scale = FALSE)
  B <- Bcoef(VAR)
  for (i in 1:runs) {
    booted <- sample(c(1:obs), replace = TRUE)
    resid <- resorig[booted, ]
    lasty <- c(t(VAR$y[p:1, ]))
    ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
    for (j in 1:obs) {
      lasty <- lasty[1:(K * p)]
      Z <- c(lasty, Zdet[j, ])
      ysampled[j + p, ] <- B %*% Z + resid[j, ]
      lasty <- c(ysampled[j + p, ], lasty)
    }
    varboot <- update(VAR, y = ysampled)
    if (class(x) == "svarest") {
      varboot <- update(x, x = varboot)
    }
    BOOT[[i]] <- .irf(x = varboot, n.ahead = n.ahead, ortho = ortho, 
                      cumulative = cumulative, impulse = impulse, response = response,shock=shock, 
                      y.names = y.names)
  }
  lower <- ci/2
  upper <- 1 - ci/2
  mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  Lower <- list()
  Upper <- list()
  idx1 <- length(impulse)
  idx2 <- length(response)
  idx3 <- n.ahead + 1
  temp <- rep(NA, runs)
  for (j in 1:idx1) {
    for (m in 1:idx2) {
      for (l in 1:idx3) {
        for (i in 1:runs) {
          if (idx2 > 1) {
            temp[i] <- BOOT[[i]][[j]][l, m]
          }
          else {
            temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
          }
        }
        mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
        mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
      }
    }
    colnames(mat.l) <- response
    colnames(mat.u) <- response
    Lower[[j]] <- mat.l
    Upper[[j]] <- mat.u
  }
  names(Lower) <- impulse
  names(Upper) <- impulse
  result <- list(Lower = Lower, Upper = Upper)
  return(result)
}

## final IRF

irf_corrected <- function (x, impulse = NULL, response = NULL, n.ahead = 10, ortho = TRUE, 
                           cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL, shock=0.1,
                           ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  y.names <- colnames(x$y)
  if (is.null(impulse)) {
    impulse <- y.names
  }
  else {
    impulse <- as.vector(as.character(impulse))
    if (any(!(impulse %in% y.names))) {
      stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
    }
    impulse <- subset(y.names, subset = y.names %in% impulse)
  }
  if (is.null(response)) {
    response <- y.names
  }
  else {
    response <- as.vector(as.character(response))
    if (any(!(response %in% y.names))) {
      stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
    }
    response <- subset(y.names, subset = y.names %in% response)
  }
  irs <- .irf(x = x, impulse = impulse, response = response, 
              y.names = y.names, n.ahead = n.ahead, ortho = ortho, 
              cumulative = cumulative,shock=shock)
  Lower <- NULL
  Upper <- NULL
  if (boot) {
    ci <- as.numeric(ci)
    if ((ci <= 0) | (ci >= 1)) {
      stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
    }
    ci <- 1 - ci
    BOOT <- .boot(x = x, n.ahead = n.ahead, runs = runs, 
                  ortho = ortho, cumulative = cumulative, impulse = impulse, 
                  response = response, ci = ci, seed = seed, shock=shock,y.names = y.names)
    Lower <- BOOT$Lower
    Upper <- BOOT$Upper
  }
  
  result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
                 impulse = impulse, ortho = ortho, cumulative = cumulative, 
                 runs = runs, ci = ci, boot = boot, shock=shock,model = class(x))
  class(result) <- "varirf"
  return(result)
}


## LO to Probs

LOtoProb <- function(x){
  odds <- exp(x)
  prob <- odds/(1+odds)
  return(prob)
}


## Relative Risk
RR <- function(x,or) {return(or/(1-x+(x*or)))}



DeltaLOtoDeltaProb<-function(x,impulse,response,delta=NULL){
  
  #BaseRate      <- median(response)
  BaseRate      <- matrixStats::colMedians(as.matrix(LOtoProb(ts.mat)))
  sqrt.sigma.jj <- (sd(impulse))
  
  if(is.null(delta)){
    delta=2*sqrt.sigma.jj
  }
  
  odds_ratio     <- exp(x/sqrt.sigma.jj *(delta/sqrt.sigma.jj))
  relative_risk  <- sapply(1:ncol(odds_ratio),FUN= function(k) RR(BaseRate[k],odds_ratio[,k]))[1,]  
  prob_change    <- 100*(relative_risk*BaseRate-BaseRate)
  
  return(prob_change)
}

